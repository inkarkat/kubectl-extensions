#!/bin/bash

: ${KUBECTL_WAIT_MAX_UPTIME_IN_SECONDS_FOR_NEWNESS=60}

printUsage()
{
    cat <<HELPTEXT
Wait until CONTAINER in POD is running again [and execute the kubectl SUBCOMMAND
with the POD -c CONTAINER arguments then]. With --no-initial-wait, only starts
waiting after the currently running POD goes down.
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-W|--no-initial-wait] [-n|--namespace NAMESPACE] POD [-c CONTAINER] [SUBCOMMAND ...] [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-W|--no-initial-wait] [-n|--namespace NAMESPACE] [SUBCOMMAND ...] -- POD [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-W|--no-initial-wait] [-n|--namespace NAMESPACE] [SUBCOMMAND ...] [--] POD -c CONTAINER [-?|-h|--help]'
}

# Extract the --namespace argument; it may appear anywhere, so we need to go through all command-line arguments and filter them out.
typeset -a kubectlNamespaceArgs=()
typeset -a allargs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--no-initial-wait|-W)	shift; KUBECTL_WAIT_MAX_UPTIME_IN_SECONDS_FOR_NEWNESS=2147483647;;
	--namespace|-n)		kubectlNamespaceArgs+=("$1" "$2"); shift; shift;;
	*)			allargs+=("$1"); shift;;
    esac
done
set -- "${allargs[@]}"

case "$1" in
    --help|-h|-\?)  shift; printUsage "$0"; exit 0;;
esac
[ $# -eq 0 ] && { printUsage "$0" >&2; exit 2; }

if [ "${@:(-2):1}" = '-c' ]; then
    # [SUBCOMMAND ...] [--] POD -c CONTAINER
    podPattern=${@:(-3):1}
    container=${!#}
    [ "${@:(-3):1}" = '--' ] && \
	set -- "${@:1:$(($#-4))}" || \
	set -- "${@:1:$(($#-3))}"
elif [ "${@:(-2):1}" = '--' ]; then
    # [SUBCOMMAND ...] -- POD
    podPattern=${!#}
    container=
    set -- "${@:1:$(($#-2))}"
else
    # POD [-c CONTAINER] [SUBCOMMAND ...]
    podPattern=$1; shift
    container=
    if [ "$1" = -c ]; then
	container=$2
	shift; shift
    fi
fi


typeset -a podFilter=(grep -e "^[^ ]*$podPattern"); shift
: ${KUBECTL_IGNORE_CONTAINERNAMES=kubernetes-vault-renew}
typeset -a containerFilter=()
if [ "$container" ]; then
    containerFilter=(sed -e "s#\\( -c [^ ]\\+ [^ ]\\+\\)*\\( -c ${container} [^ ]\\+\\)\\( -c [^ ]\\+ [^ ]\\+\\)*\$#\\2#")
elif [ "$KUBECTL_IGNORE_CONTAINERNAMES" ]; then
    ignoredContainerBranches="${KUBECTL_IGNORE_CONTAINERNAMES// /\\|}"
    containerFilter=(sed -e "s# -c \\(${ignoredContainerBranches}\\) [^ ]\\+\\( \\|\$\\)#\\2#")
fi

if which reldate > /dev/null 2>&1; then
    showDate()
    {
	reldate <<<"$1"
    }
    showDuration()
    {
	printf 'since '
	reldate <<<"$1"
    }
else
    showDate()
    {
	date --set "$1"
    }
    showDuration()
    {
	local now=$(date +%s)
	local lastEpoch=$(date --date "$1" +%s)
	local stateDurationInSeconds=$((now - lastEpoch))
	stateDurationInSecondsPlural=s; [ $stateDurationInSeconds -eq 1 ] && stateDurationInSecondsPlural=
	printf 'for %d second%s\n' "$stateDurationInSeconds" "$stateDurationInSecondsPlural"
    }
fi
statusprintf()
{
    typeset format=$1; shift
    printf >&2 "[1F[2K${format}\n" "$@"
}
spinningprintf()
{
    typeset SPINNER='/-\|'
    typeset format=$1; shift
    printf >&2 "[1F[2K${format} %s\\n" "$@" "${SPINNER:$((SECONDS % 4)):1}"
}

getPodContainerStartTimes()
{
    kubectl get "$@" -o go-template --template '{{range .items}}{{.metadata.name}}{{range .status.containerStatuses}} -c {{.name}} {{if .state.running}}{{.state.running.startedAt}}{{else}}{{ range $key, $value := .state }}{{$key}}{{end}}{{end}}{{end}}{{"\n"}}{{end}}' pod
}
parse()
{
    mapfile results

    if [ ${#results[@]} -eq 0 ]; then
	printf -v kcCommand '%q ' kubectl get pod "${kubectlNamespaceArgs[@]}" ${podFilter:+|} "${podFilter[@]}" ${containerFilter:+|} "${containerFilter[@]}"
	spinningprintf 'ERROR: No results for %s' "${kcCommand// \\| / | }"
	exit 1
    elif [ ${#results[@]} -gt 1 ]; then
	echo >&2 "ERROR: Multiple PODs match:"
	printf >&2 '%s\n' "${results[@]%% *}"
	exit 1
    fi

    local IFS=' '
    read -r pod containerArg container startTimeOrState remainder <<< "${results[0]}"
    : "${pod:?}" "${containerArg:?}" "${container:?}" "${startTimeOrState:?}"

    local startEpoch
    if ! startEpoch=$(date --date "$startTimeOrState" +%s 2>/dev/null); then
	read -r lastState lastDate < "$lastStateFilespec"

	if [ "$lastState" = "$startTimeOrState" -a "$lastDate" ]; then
	    spinningprintf '%s -c %s has been in status %s %s.' "$pod" "$container" "$startTimeOrState" "$(showDuration "$lastDate")"
	else
	    printf >&2 '%s %s\n' "$startTimeOrState" "$(date --utc +%FT%TZ)" > "$lastStateFilespec"
	    spinningprintf '%s -c %s is currently in status %s.' "$pod" "$container" "$startTimeOrState"
	fi

	return
    fi

    local now=$(date +%s)
    local uptimeInSeconds=$((now - startEpoch))

    if [ $uptimeInSeconds -gt $KUBECTL_WAIT_MAX_UPTIME_IN_SECONDS_FOR_NEWNESS ]; then
	spinningprintf '%s -c %s is not yet down (started %s).' "$pod" "$container" "$(showDate "$startTimeOrState")"
	return
    fi

    uptimePlural=s; [ $uptimeInSeconds -eq 1 ] && uptimePlural=
    statusprintf '%s -c %s started %d second%s ago.' "$pod" "$container" "$uptimeInSeconds" "$uptimePlural"
    if [ $# -gt 0 ]; then
	# Some kubectl commands (e.g. exec -it) need to read from stdin; restore it.
	exec 0<&6

	local kubectlAlias="kubectl-$1"
	if type -t "$kubectlAlias" >/dev/null; then
	    shift
	    eval $kubectlAlias '"$@" "${kubectlNamespaceArgs[@]}" "$pod" "$containerArg" "$container"'
	else
	    command kubectl "$@" "${kubectlNamespaceArgs[@]}" "$pod" "$containerArg" "$container"
	fi
    fi
    exit 99
}



exec 6<&0   # Save stdin.

lastStateFilespec=$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$$RANDOM")
> "$lastStateFilespec"
[ "$DEBUG" ] || trap 'rm "$lastStateFilespec" 2>/dev/null' EXIT

while :
do
    eval 'getPodContainerStartTimes "${kubectlNamespaceArgs[@]}"' "${podFilter:+|}" '"${podFilter[@]}"' "${containerFilter:+|}" '"${containerFilter[@]}"' | \
	parse "$@"
    status=$?
    case $status in
	0)  sleep 3s;;
	99) exit 0;;
	*)  exit $status;;
    esac
done
